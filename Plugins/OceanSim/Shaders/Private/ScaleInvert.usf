#include "/OceanShaders/Private/CoordinateToIndex.ush"

StructuredBuffer<float2> HeightBuffer;
StructuredBuffer<float2> DisplacementXBuffer;
StructuredBuffer<float2> DisplacementYBuffer;
StructuredBuffer<float2> SlopeXBuffer;
StructuredBuffer<float2> SlopeYBuffer;

RWTexture2D<float4> DisplacementTexture;
RWTexture2D<float2> SlopeTexture;

float FoamLambda;



uint WrapValue(int Value, int Range)
{
    return (Value + Range) % Range;
}

uint2 WrapCoordinate(int2 Coordinate)
{
    uint2 Result;
    
    Result.x = WrapValue(Coordinate.x, BufferSize.x);
    Result.y = WrapValue(Coordinate.y, BufferSize.y);

    return Result;
}

float Jacobian(int2 Coordinate, float Factor)
{
    // Since the sampled coordinates will always be adjacent, we know that
    // the (-1)^(N+M) factor will be inverted
    // (N+M) will always be odd if the adjacent (N+M) is even and vice versa
    Factor = -Factor;
    
    // Create indices of adjacent texels, wrapping at edges
    int XIndex1 = CoordinateToIndex(WrapCoordinate(Coordinate - int2(1, 0)));
    int XIndex2 = CoordinateToIndex(WrapCoordinate(Coordinate + int2(1, 0)));
    
    int YIndex1 = CoordinateToIndex(WrapCoordinate(Coordinate - int2(0, 1)));
    int YIndex2 = CoordinateToIndex(WrapCoordinate(Coordinate + int2(0, 1)));
    
    // Approximate partial derivatives using slope
    float dXdX = FoamLambda * Factor * (DisplacementXBuffer[XIndex2].x - DisplacementXBuffer[XIndex1].x) / 2;
    float dXdY = FoamLambda * Factor * (DisplacementXBuffer[YIndex2].x - DisplacementXBuffer[YIndex1].x) / 2;
    
    float dYdX = FoamLambda * Factor * (DisplacementYBuffer[XIndex2].x - DisplacementYBuffer[XIndex1].x) / 2;
    float dYdY = FoamLambda * Factor * (DisplacementYBuffer[YIndex2].x - DisplacementYBuffer[YIndex1].x) / 2;
    
    // Calculate the Jacobian determinant
    return (1 + dXdX) * (1 + dYdY) - dXdY * dYdX;

}

[numthreads(8, 8, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    float Factor = 1 / float(BufferSize.x * BufferSize.y);
    if ((id.x + id.y) % 2 == 1)
    {
        Factor = -Factor;
    }
    
    uint Index = CoordinateToIndex(id.xy);
    
    float HeightValue = HeightBuffer[Index].x;
    float DisplacementXValue = DisplacementXBuffer[Index].x;
    float DisplacementYValue = DisplacementYBuffer[Index].x;
    
    float SlopeXValue = SlopeXBuffer[Index].x;
    float SlopeYValue = SlopeYBuffer[Index].x;
    
    DisplacementTexture[id.xy] = float4(float3(DisplacementXValue, DisplacementYValue, HeightValue) * Factor, Jacobian(id.xy, Factor));
    SlopeTexture[id.xy] = float2(SlopeXValue, SlopeYValue) * Factor;

}